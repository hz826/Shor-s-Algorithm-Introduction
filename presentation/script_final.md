首先是为什么要去研究和发展量子计算的理论，他对于传统的计算机有着什么优势，我们今天所要研究的问题就是一个比较具体的例子

一般而言，计算两个大质数的乘积很容易，但将大整数分解则是一个很难的问题。

对于传统计算机也是如此，计算两个数千位大质数的乘积，就是很普通的计算机也可以轻易完成；但若是分解为两个大质数，即使是最先进的计算机，仅仅用简单的枚举法，花费数万年也不可能做到。

基于大数分解难题，科学家设计出了$RSA$公钥加密算法

但随着量子计算理论的发展，彼得·肖尔在1994年提出的$shor$算法，使量子计算机理论上可以快速完成大数分解





那么，什么是$shor$算法，如何用量子计算机分解质因数





$shor$算法分为传统部分和量子部分，

先使用传统计算机，将分解问题转换为求阶问题，再使用量子计算机，通过量子模意义乘法电路和量子傅里叶变换，高效求出指定元素的阶，从而实现分解

对于输入的大整数 $N$ ，需要使用 $O(log N) $个量子比特实现这一过程





下面的是传统部分的主要流程

找一个整数小于$N$的整数$a$ , 计算它和$N$的最大公因数，他们有极低的概率不互质，那自然得到了 $N$ 的一个非平凡因子，当然这几乎不可能发生

而绝大多数情况，他们的最大公因数为1，则用量子算法找到 $a$ 模 $N$ 的阶，也就是最小的满足 $a^r \equiv 1 \pmod N$ 的正整数 $r$

如果 $r$ 是偶数，并且$a^{\frac r2} \not\equiv -1 \pmod N$ 那么可以证明$a^{\frac r2}+1和a^{\frac r2}-1$与N的最大公因数都是N的非平凡因子





接下来只需要关注对于随机的 $a$ ，这个算法的成功率，也就是 $r=\text{ord}_N(a)$ 为偶数，且 $a^{\frac r2} \not\equiv -1 \pmod N$ 的概率，我们可以通过观察模 $N$ 乘法群 $(\Z/N\Z)^\times$ 的结构得到答案：

根据群论知识，模$N$乘法群可以分解为若干循环群的直积





将N进行分解质因数，表示为$p_i$的$\alpha_i$次方的乘积

如图所示定义$\ r_i = \mathrm{ord}_{p_i^{\alpha_i}}(a)$，$r$为所有$r_i$的最小公倍数，$2\nmid r \iff \forall i,\ 2\nmid r_i$ 

$v_2(n)$表示$n$中$2$的因子次数

通过以下推导，可以得出

对于随机的整数 $a$ ，不能通过 $a$ 找到 $N$ 的非平凡因子当且仅当 $\forall i,j,\ v_2(r_i) = v_2(r_j)$





考虑 $r_i$ 的分布，根据中国剩余定理，$\forall i\neq j,\ r_i$ 与 $r_j$ 的分布是独立的

对于与$N$ 互质 $a$ ，失败概率为$P(f_2(r_i) = t)$的和的乘积

只有 $N = p^k,\ 2p^k,\ (k\ge 1)$ 时失败概率恒为$1$，其他情况失败概率均小于$\frac12$

对于特殊的情况简单的特判后，该算法的成功率是相当理想的





传统部分就到此结束，然后是$shor$算法的重点，量子部分：通过量子电路实现高效的求阶算法

由于量子具有叠加态和纠缠态的性质，仅 $q$ 个量子比特就可以表示一个长度为 $2^q$ 的复向量，而传统计算机需要 $2^q$ 个浮点数表示，它们的模长的平方之和为 $1$ ，对它们进行测量时，有 $|c_i|^2$ 的概率测得状态 $\ket{i}$

所有的量子电路门可以通过乘一个酉矩阵表示，即满足 $UU^\dagger=I$ 的可逆矩阵

通过酉矩阵的叠加，可以实现量子加法器、量子乘法器，量子傅里叶变换等功能





$shor$算法量子电路部分的大致流程如下：

如图，使用 $2n$ 个量子比特进行控制， $n$ 个量子比特进行模意义乘法运算

一开始，我们用 $Hadamard$ 门和 $X$ 门将状态初始化为 $\ket{\psi_0}$，如图所示





下一步，如图所示，$Ua$为模意义乘法门，$QFT$为量子傅里叶变化电路。使用前 $2n$ 个量子比特控制乘法门，后 $n$ 个量子比特计算乘法，当 $\ket x$ 的第 $i$ 位为 $1$ 时，会使控制乘法电路使答案乘上 $a^{2^i}$

此时的量子态是 $\ket{\psi}$ 如上式

这样，我们通过量子计算的并行特性就得到了 $a$ 的 $0$ 到 $Q-1$ 次幂，因为 $a^r \equiv 1 \pmod N$，这是一个以 $r$ 为周期的数列





这是在$a=2\ N=13\ r=12\ Q=256$时

我们对前 $2n$ 个量子比特做 $QFT$ ，并进行测量，结果如图所示，后 $n$ 位不同的量子态得到了几乎一样的结果，并且都有 $r$ 个峰值等间距分布，我们将证明为什么 $QFT$ 能得到这样的结果





由周期性，量子态可以这样表示

因为只对前 $2n$ 个量子比特进行了 $QFT$，所以在经过 $QFT$ 后，后 $n$ 位不同的量子态之间不会互相影响

因此，只考虑 $f(x)=z$ 的情况，观察 $QFT$ 的结果





QFT的结果如上式所述

画出 $\omega$ 的幅角与 $P(\ket{y,z})$ 关系的图像，可以证明，函数关于 $y$ 轴对称，而且在 $[0,\omega_Q^{Q/m}]$ （大约是 $[0,\omega_Q^r]$ ）内单调递减





模拟这个过程，当幅角从 $0$ 递增到 $\omega_Q^{(Q-1)r}$，$\omega$ 会绕 $x$ 轴旋转 $r$ 圈，每经过 $r$ 轴一次，一定存在一个 $y_i$ 满足 $\omega_Q^{ry_i}$ 的幅角在 $\omega_Q^{-\frac r2}$ 到 $\omega_Q^{\frac r2}$ 之间

因此概率满足如下不等式

在前 $2n$ 个量子比特中，有 $r$ 个 $y_i$ 满足 $P(\ket{y_i}) \ge 0.4 \frac 1r$





最后，我们还需要找到 $y_i$ 与 $r$​ 的关系，已知：$\exists d \in \{0,1,\dots r-1\}$ （圈数），$|ry_i-dQ|\le \frac{r}{2}$

两边同除 $Qr$ ，$|\frac{y}{Q}-\frac{d}{r}| \le \frac{1}{2Q}$ ，其中 $\frac{y}{Q}$ 已知，而 $\frac{d}{r}$ 是一个分子分母均小于 $N$ 的分数

同于两个这样的不同的分数，容易证明其间距是大于$\frac1Q$的，这也是控制部分需要 $2n$ 个量子比特的原因

此时，通过 $\frac{y}{Q}$ 可以唯一确定 $\frac{d}{r}$

综上，周期r可以被推导出来





现在问题只剩下最关键的一步：如何构建模意义乘法运算，在这里，我们参考这篇论文，给出一种构造





量子加法器有很多种实现方法，这里介绍的是一种基于 $QFT$ 的加法器，对于 $n$ 个量子比特，它实现了模 $2^n$ 的加法，并且不需要辅助量子比特

$QFT$ 能将一个数转为它的相位，而逆变换可以将相位转换为数

$\ket{a}$ 与 $\ket{a+b}$ 之间的关系较难找出，但 $\ket{\phi(a)}$ 与 $\ket{\phi(a+b)}$ 之间有着非常明显的关系，他们相差 $\omega_Q^{bx}$ 的相位具有线性性，以此可以简单的构造出相位加法门

在两边加上 $QFT$ 和逆 $QFT$ 即可得到量子加法门





这是一个（模 $N$，加常数）加法器

模意义加法可以如上图表示

先计算 $a+b-N$ ，用一个辅助量子比特记录结果是否小于 $0$ 

但还需要扩充一位用于区分是否溢出，因此需要两个辅助量子比特

而恢复记录溢出用的量子比特并不难实现，可以节省量子比特的使用

如图所示

由于之后乘法器需要，还需要将其设计成受控的





模 $N$，乘常数乘法器

将 $n$ 个加法器组合，就能得到一个乘加器，这里需要 $n$ 个辅助量子比特用于储存计算结果

同样地，也需要通过重叠两个乘加器恢复辅助量子比特

如下图





这样，就成功构造了一种乘法器，并得到了一个使用 $4n+2$ 个量子比特的求阶算法，我们也在 $pyqpanda$ 中成功模拟了这一电路





如果进一步优化电路，通过对 $QFT$ 电路的观察，能够提前测量一些控制量子比特，并复用它们，最终可以优化到 $2n+3$ 个量子比特

由于时间有限，这里就只给出大致的量子电路图而不做具体的讲解





$shor$算法提供了一种未来彻底破解$RSA$加密算法的可能性，但是密码学也有相关的针对量子计算攻击量子$hard$问题

当然，比起破解$RSA$，$shor$算法更展现出了量子计算的实用性





以下是我们在学习该量子计算过程中主要的参考文献

本次量子计算大作业所有代码都已上传我们项目的 $github$ 仓库，链接可以在评论区找到



